# 序列（sequence）
在Python中，最基本的数据结构为序列（sequence）。序列中的每个元素都有编号，即其位置或索引，其中第一个元素的索引为0，第二个元素的索引为1，依此类推  
最常用的序列有：列表和元组，字符串。

# 通用的序列操作
有几种操作适用于所有序列，包括索引、切片、相加、相乘和成员资格检查。另外，Python还提供了一些内置函数，可用于确定序列的长度以及找出序列中最大和最小的元素。

### 索引（indexing）
* 序列中的所有元素都有编号——从0开始递增。  
  * 注意：Python没有专门用于表示字符的类型，因此一个字符就是只包含一个元素的字符串。
```python
greeting="Hello"
x=greeting[0]  # 'H'
x=greeting[-1] # 'o'
```

* 如果函数调用返回一个序列，可直接对其执行索引操作。
```py
>>> fourth = input('Year: ')[3]
Year: 2005
>>> fourth
'5' 
```

### 切片（slicing）
* 切片适用于提取序列的一部分，其中的编号非常重要：第一个索引是包含的第一
个元素的编号，但第二个索引是切片后余下的第一个元素的编号
```py
>>> numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> numbers[3:6] [4, 5, 6]
>>> numbers[0:1] [1]
```

* 切片简写
```py
>>> numbers[7:10]  #[8, 9, 10]
>>> numbers[-3:-1] #[8, 9]
>>> numbers[-3:0]  #[] 
>>> numbers[-3:]   #[8, 9, 10]
>>> numbers[:3]    #[1, 2, 3]
```
* 切片复制
```py
>>> a=[1,2,3,4]
>>> b=a[:]
>>> c=a
>>> b[0]=2
>>> c[0]=3
>>> a #[3, 2, 3, 4]
>>> b #[2, 2, 3, 4]
>>> c #[3, 2, 3, 4]
```

* 步长
执行切片操作时，你显式或隐式地指定起点和终点，但通常省略另一个参数，即步长。在普
通切片中，步长为1。这意味着从一个元素移到下一个元素，因此切片包含起点和终点之间的所
有元素。   
```py
>>> numbers[0:10:1]  #[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> numbers[0:10:2]  #[1, 3, 5, 7, 9]
>>> numbers[3:6:3]   #[4] 
>>> numbers[::4]     #[1, 5, 9]
```
当然，步长不能为0，否则无法向前移动，但可以为负数，即从右向左提取元素。  
```py
>>> numbers[8:3:-1]   #[9, 8, 7, 6, 5]
>>> numbers[10:0:-2]  #[10, 8, 6, 4, 2]
>>> numbers[0:10:-2]  #[]
>>> numbers[::-2]     #[10, 8, 6, 4, 2] 
>>> numbers[5::-2]    #[6, 4, 2]
>>> numbers[:5:-2]    #[10, 8]
```

### 序列相加  
* 可使用加法运算符来拼接序列。  
```py
>>> [1, 2, 3] + [4, 5, 6]
[1, 2, 3, 4, 5, 6]
>>> 'Hello,' + 'world!'
'Hello, world!'
>>> [1, 2, 3] + 'world!'
Traceback (innermost last):
 File "<pyshell>", line 1, in ?
 [1, 2, 3] + 'world!'
TypeError: can only concatenate list (not "string") to list
```

### 乘法
* 将序列与数x相乘时，将重复这个序列x次来创建一个新序列  
```py
>>> 'python' * 5
'pythonpythonpythonpythonpython'
>>> [42] * 10
[42, 42, 42, 42, 42, 42, 42, 42, 42, 42]
```

### 成员资格
* 要检查特定的值是否包含在序列中，可使用运算符in 
```py
>>> permissions = 'rw'
>>> 'w' in permissions  #True
>>> 'x' in permissions  #False
>>> users = ['mlh', 'foo', 'bar']
>>> input('Enter your user name: ') in users
Enter your user name: mlh
True
>>> subject = '$$$ Get rich now!!! $$$'
>>> '$$$' in subject    #True
```
*  检查用户名和PIN码
```py
database = [
 ['albert', '1234'],
 ['dilbert', '4242'],
 ['smith', '7524'],
 ['jones', '9843']
]
username = input('User name: ')
pin = input('PIN code: ')
if [username, pin] in database: print('Access granted')
```

### 长度、最小值和最大值
* 内置函数len、min和max  
```py
>>> numbers = [100, 34, 678]
>>> len(numbers)  #3
>>> max(numbers)  #678
>>> min(numbers)  #34
```


# 列表List
列表是可变的，即可修改其内容   
### 函数 list
```py
>>> x=list('hello')
>>> x  #['h', 'e', 'l', 'l', 'o']
>>> y=''.join(x)
>>> y  #'hello'
```

### 修改列表：给元素赋值  
```py
>>> x = [1, 1, 1]
>>> x[1] = 2
>>> x #[1, 2, 1] 
```

### 删除元素
```py
>>> names = ['Alice', 'Beth', 'Cecil', 'Dee-Dee', 'Earl']
>>> del names[2]
>>> names
['Alice', 'Beth', 'Dee-Dee', 'Earl'] 
```

### 给切片赋值
* 通过使用切片赋值，可将切片替换为长度与其不同的序列。  
```py
>>> name = list('Perl')
>>> name[1:] = list('ython')
>>> name #['P', 'y', 't', 'h', 'o', 'n']
```
* 使用切片赋值还可在不替换原有元素的情况下插入新元素。
```py
>>> numbers = [1, 5]
>>> numbers[1:1] = [2, 3, 4]
>>> numbers #[1, 2, 3, 4, 5] 
```
* 在这里，我“替换”了一个空切片，相当于插入了一个序列。你可采取相反的措施来删除切片
```py
>>> numbers
[1, 2, 3, 4, 5]
>>> numbers[1:4] = []
>>> numbers #[1, 5]
```

### 方法
方法是与对象（列表、数、字符串等）联系紧密的函数。通常，像下面这样调用方法：  
object.method(arguments)  

* append
方法append用于将一个对象附加到列表末尾。  
append也就地修改列表。这意味着它不会返回修改后的新列表，而是直接修改旧列表  
```py
>>> lst = [1, 2, 3]
>>> lst.append(4)
>>> lst #[1, 2, 3, 4]
```

* clear
方法clear就地清空列表的内容。  
这类似于切片赋值语句lst[:] = []。  
```py
>>> lst = [1, 2, 3]
>>> lst.clear()
>>> lst  #[]
```

* copy  
方法 copy 复制列表。前面说过，常规复制只是将另一个名称关联到列表。  
```py
>>> a = [1, 2, 3]
>>> b = a
>>> b[1] = 4
>>> a   #[1, 4, 3] 
>>> a = [1, 2, 3]
>>> b = a.copy()
>>> b[1] = 4
>>> a   #[1, 2, 3] 
```

* count
方法count计算指定的元素在列表中出现了多少次。  
```py
>>> ['to', 'be', 'or', 'not', 'to', 'be'].count('to') #2
>>> x = [[1, 2], 1, 1, [2, 1, [1, 2]]]
>>> x.count(1) #2
>>> x.count([1, 2]) #1 
```
* extend
方法extend让你能够同时将多个值附加到列表末尾，为此可将这些值组成的序列作为参数提
供给方法extend。换而言之，你可使用一个列表来扩展另一个列表。  
```py
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> a.extend(b)
>>> a
[1, 2, 3, 4, 5, 6]
```
拼接，需要创建新的列表  
```py
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> a + b
[1, 2, 3, 4, 5, 6]
>>> a
[1, 2, 3] 

* index
方法index在列表中查找指定值第一次出现的索引。
```py
>>> knights = ['We', 'are', 'the', 'knights', 'who', 'say', 'ni']
>>> knights.index('who') #4 
```

* insert
方法insert用于将一个对象插入列表。  
```py
>>> numbers = [1, 2, 3, 5, 6, 7]
>>> numbers.insert(3, 'four')
>>> numbers
[1, 2, 3, 'four', 5, 6, 7]
```
与extend一样，也可使用切片赋值来获得与insert一样的效果。但是可读性很差  
```py
>>> numbers = [1, 2, 3, 5, 6, 7]
>>> numbers[3:3] = ['four']
>>> numbers
[1, 2, 3, 'four', 5, 6, 7]
```

* pop
方法pop从列表中删除一个元素（末尾为最后一个元素），并返回这一元素。  
```py
>>> x = [1, 2, 3]
>>> x.pop()   #3
>>> x         #[1, 2]
>>> x.pop(0)  #1
>>> x         #[2]
```

* remove
方法remove用于删除第一个为指定值的元素。  
```py
>>> x = ['to', 'be', 'or', 'not', 'to', 'be']
>>> x.remove('be')
>>> x   #['to', 'or', 'not', 'to', 'be'] 
```

* reverse
```py
>>> x = [1, 2, 3]
>>> x.reverse()
>>> x  #[3, 2, 1]
```

* sort
方法sort用于对列表就地排序。就地排序意味着对原来的列表进行修改，使其元素按顺序
排列，而不是返回排序后的列表的副本。  
```py
>>> x = [4, 6, 2, 1, 7, 9]
>>> x.sort()
>>> x
[1, 2, 4, 6, 7, 9]
>>> y = x.sort() # Don't do this!
>>> print(y)
None
```

```py
>>> x = [4, 6, 2, 1, 7, 9]
>>> y = x.copy()
>>> y.sort()
>>> x #[4, 6, 2, 1, 7, 9]
>>> y #[1, 2, 4, 6, 7, 9]
```

# 元组：不可修改的序列tuple
与列表一样，元组也是序列，唯一的差别在于元组是不能修改的（你可能注意到了，字符串
也不能修改）。元组语法很简单，只要将一些值用逗号分隔，就能自动创建一个元组。  
元组还可用圆括号括起（这也是通常采用的做法）。  
```py
>>> 1, 2, 3
(1, 2, 3)
```
如何表示只包含一个值的元组呢？这有点特殊：虽然只有一个值，也必须在它
后面加上逗号。  
```py
>>> 42  #42
>>> 42, #(42,) 
>>> 3 * (40 + 2)    #126
>>> 3 * (40 + 2,)   #(42, 42, 42)
```

```py
>>> tuple([1, 2, 3])
(1, 2, 3)
>>> tuple('abc')
('a', 'b', 'c')
>>> tuple((1, 2, 3))
(1, 2, 3)
```
